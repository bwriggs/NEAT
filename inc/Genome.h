#pragma once

//Genetic encoding of a recurrent neural network
//generated by NEAT

#include <cstdlib>
#include <list>

#include "LibNeat.h"
#include "Phenotype.h"


class Random;
class InnovationTracker;
class Parameters;

struct NodeGene {
    //3 regular node types + bias + default for defualt ctor
    enum class NodeType {Input, Hidden, Output, Bias, Default};
    NodeType nodeType;
    size_t id;

    NodeGene(NodeType = NodeType::Default, size_t=0);
};

std::ostream &operator<<(std::ostream&, const NodeGene&);

struct ConnectionGene {
    size_t from, to;
    double weight;
    //enable bit (for natural selection analogy and for addNode mutation)
    bool enabled;
    //historical origin of this gene, used to find versions of this
    //gene in other Genomes
    size_t innovationNumber;

    ConnectionGene(size_t, size_t, double, bool = true, size_t = 0);
};

std::ostream &operator<<(std::ostream&, const ConnectionGene&);

//Genetic encoding of a recurrent neural network
//generated by NEAT
//
class Genome {
public:
    class Dependencies {
    public:
        virtual Random *random() = 0;
        virtual InnovationTracker *innovationTracker() = 0;
        virtual Parameters *parameters() = 0;
    };

    //ctors
    Genome(size_t, size_t, size_t, GenomeDeps*, bool = false);
    Genome(size_t, size_t, size_t, GenomeDeps*, std::list<NodeGene>, std::list<ConnectionGene>, bool = false);
    Genome();
    Genome keepStructure();
    
    //mutators
    //probably want back end
    //separated from randomness
    void addNode();
    void addConnection();
    void randomWeight();
    void perturbWeight();

    //access
    size_t id() const;
    void setId(size_t);
    const std::list<NodeGene> &getNodeGenes() const;
    const std::list<ConnectionGene> &getConnectionGenes() const;

    //cross over etc.
    //"delta" measure of similarity between networks
    //weighted sum of # excess genes, # disjoint genes,
    //average weight difference of shared genes 
    double delta(const Genome&) const;

    //make a child from these genomes
    //Lines up genes in the same way as similarity
    //The child gets a random subset of shared genes
    //The child inherits all disjoint and excess from
    //one parent (more fit or random if equal)
    Genome cross(const Genome&, double, double, size_t);

    friend std::ostream &operator<<(std::ostream&, const Genome&);
private:
    size_t inputs, outputs;
    size_t _id;
    GenomeDeps *deps;
    std::list<NodeGene> nodeGenes;
    std::list<ConnectionGene> connectionGenes;
    

    //NEAT is all about minimizing parameter space, so biases are added as
    //  AN ad-hoc node rather than always present potentially as zeros.
    //Setting the bias of a node i to b is equivalent to adding a connection
    //  from the bias node to node i with weight b.
    //If present, the bias node has id inputs
    bool useBias;

    struct AlignedGenome {
        std::vector<const ConnectionGene*> disjoint;
        std::vector<const ConnectionGene*> excess;
        std::vector<const ConnectionGene*> match;
    };

    struct NodeCompare {
        constexpr bool operator()(const NodeGene &lhs, const NodeGene &rhs) const {
            return lhs.id < rhs.id;
        }
    };

    struct ConnCompare {
        constexpr bool operator()(const ConnectionGene &lhs, const ConnectionGene &rhs) const {
            return lhs.innovationNumber < rhs.innovationNumber;
        }
    };

    //used by cross and delta for fast structural analysis
    std::pair<AlignedGenome, AlignedGenome> alignGenomes(const Genome&) const;

    //allow the real network to see
    //this description
    friend class Phenotype;
};
